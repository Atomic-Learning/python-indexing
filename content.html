
<p>Many Python collections have items that are ordered and accessible by position, expressed as an integer index. When we do this to return a single item from a collection, it is called <strong>indexing</strong>. Common indexable types include strings, lists, tuples, and Numpy arrays. Here, we'll use lists and strings as examples.</p>

<h2>Zero-Based Indexing</h2>

<p>To retrieve an item from a sequence in Python, you use an integer index in square brackets following the variable what references the collection. In Python, the index of the first item is <strong>0</strong>, not 1. This is called <strong>zero-based indexing</strong>. The following example demonstrates this with a string:</p>

<py-cell>word = "hello"
#       01234  (indices)

print(word[0])
print(word[1])
print(word[4])</py-cell>

<h2>Negative Indexing</h2>

<p>You can also use <strong>negative indices</strong> to count from the end. Index <code>-1</code> is the last item, <code>-2</code> is the second-to-last, and so on. The following example demonstrates this with a list:</p>

<py-cell>numbers = [10, 20, 30, 40, 50]

print(numbers[-1])
print(numbers[-2])
print(numbers[-5])</py-cell>

<p>Negative indexing is useful when you want items near the end without calculating the length first.</p>

<h2>Returned Type</h2>

<p>The exact type of the item returned varies a little by the type of collection being indexed. Many collections, such as lists, store arbitrary Python objects, so indexing returns an object of whatever type was stored in that position. For strings, indexing always returns a string of length 1:</p>

<py-cell>text = "Python"
print(type(text[0]))

my_list = [1, 2, 3.5] # A list of integers and floats
print(type(my_list[0]))
print(type(my_list[2]))</py-cell>
